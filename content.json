{"meta":{"title":"随笔","subtitle":"技术 | 生活","description":"屈子泪，离歌起，力拔山兮","author":"Jack","url":"http://mrzzcn.github.io"},"posts":[{"title":"使用 Heroku 和 mongoDB Atlas 免费托管 YApi","slug":"host-yapi-with-heroku-and-mongodb-atlas","date":"2019-04-27","updated":"2019-04-27","comments":true,"path":"2019/04/27/host-yapi-with-heroku-and-mongodb-atlas/","link":"","permalink":"http://mrzzcn.github.io/2019/04/27/host-yapi-with-heroku-and-mongodb-atlas/","excerpt":"0. 背景前端开发过程中，与后端约定接口标准之后，双方同时开始开发，可能会出现后端没有 Ready，但是前端已经需要使用接口的情况。这时候就需要 Fake 接口。有几种方式： 优点 缺点 1. 项目中使用 Fake Promise 方便快速 不能模拟真实网络请求，对代码有侵入，需要在 webpack 中配置路径替换或手动切换文件 2. 项目中使用 mockjs 等服务端方式启动自托管 mock server 方便快速，真实网络请求 增加项目体积，不利于多项目共享基础设施，耗费开发服务器性能 3. 使用单独的 mock server 真实网络请求，可集成后端接口测试，TS 代码模板等功能 需要花稍多时间维护接口 这里介绍一下使用第三种方式的一个实现方法：YApi，可以去这里体验。YApi 是 node + mongoDB 项目，本篇介绍一下自己使用 Heroku 和 mongoDB Atlas 免费部署 YApi 的过程。 1. 注册帐号https://cloud.mongodb.com/ 提供免费的 mongoDB 数据库服务https://www.heroku.com/ 提供免费的 node 程序托管服务","text":"0. 背景前端开发过程中，与后端约定接口标准之后，双方同时开始开发，可能会出现后端没有 Ready，但是前端已经需要使用接口的情况。这时候就需要 Fake 接口。有几种方式： 优点 缺点 1. 项目中使用 Fake Promise 方便快速 不能模拟真实网络请求，对代码有侵入，需要在 webpack 中配置路径替换或手动切换文件 2. 项目中使用 mockjs 等服务端方式启动自托管 mock server 方便快速，真实网络请求 增加项目体积，不利于多项目共享基础设施，耗费开发服务器性能 3. 使用单独的 mock server 真实网络请求，可集成后端接口测试，TS 代码模板等功能 需要花稍多时间维护接口 这里介绍一下使用第三种方式的一个实现方法：YApi，可以去这里体验。YApi 是 node + mongoDB 项目，本篇介绍一下自己使用 Heroku 和 mongoDB Atlas 免费部署 YApi 的过程。 1. 注册帐号https://cloud.mongodb.com/ 提供免费的 mongoDB 数据库服务https://www.heroku.com/ 提供免费的 node 程序托管服务 2. 准备2.1 建立数据库登录 https://cloud.mongodb.com/ 创建 sandbox 实例。得到类似1234# &lt;username&gt; 为用户名# &lt;password&gt; 为密码# 修改结尾处 test =&gt; yapimongodb+srv://&lt;username&gt;:&lt;password&gt;@xxxx.mongodb.net/yapi?retryWrites=true 的连接字符串。 2.3 克隆代码YApi 源码位于 https://github.com/YMFE/yapi 你可以 Fork 到你自己的仓库，然后克隆。1git clone git@github.com:YMFE/yapi.git 2.4 修改几行代码适应 Heroku 部署123456789101112131415161718192021222324252627282930313233343536cd yapi# 这里使用最新版 1.7.0 ，如果担心最新版有问题也可以切换别的版本# https://github.com/YMFE/yapi/releasesgit checkout -b dev v1.7.0 # 创建配置文件cp ./config_example.json ./config.js# 由于 YApi 项目使用 JSON 配置文件，而 JSON 中不能使用环境变量，所以我们这里改为使用 JS 配置文件# 打开 config.js 在第一行 增加 module.exports = # 找到 db 段配置# 添加 connecString 属性，值为 2.1 步得到的字符串# 修改 user 属性值为 2.1 步的 用户名# 修改 pass 属性值为 2.1 步的 密码# 打开 server/yapi.js 文件 # 修改以下行内容const config = require('../../config.json');# =&gt;const config = require('../config.js');# 打开 ykit.config.js configPlugin = require('../config.json').plugins;# =&gt;configPlugin = require('../config.js').plugins;# 打开 server/utils/initConfig.jslet configPath = path.join(runtimePath, 'config.json');# =&gt; let configPath = path.join(runtimePath, 'config.js');# 修改日志路径，因为 Heroku 根目录为只读路径，不允许程序创建或写入const WEBROOT_LOG = path.join(WEBROOT_RUNTIME, 'log');=&gt;const WEBROOT_LOG = path.resolve(__dirname, 'log'); 2.5 初始化数据库12345npm installnpm run install-server# 出现以下日志，即表示数据库初始化成功log: mongodb load success...初始化管理员账号成功,账号名：\"admin@admin.com\"，密码：\"ymfe.org\" 2.6 增加环境变量1234567891011121314151617# 打开 config.js# 修改 port 节点：process.env.PORT# 因为 Heroku 会提供一个端口用来做转发，应用程序必须通过环境变量获取这个端口并监听，否则应用无法启动# 修改 db 节点到以下内容： \"db\": &#123; \"connectString\": process.env.connectString, \"servername\": \"127.0.0.1\", \"DATABASE\": \"yapi\", \"port\": 27017, \"user\": process.env.connectUser, \"pass\": process.env.connectPass, \"authSource\": \"yapi\" &#125;,git add .git commit 3. 部署3.1 创建项目登录 https://dashboard.heroku.com/ 创建 app，例如 yapi-demo（已使用，请另外命名），创建完成之后来到项目页面：https://dashboard.heroku.com/apps/yapi-demo 3.2 配置环境变量点击 Settings -&gt; Reveal Config Vars依次添加：123connectString: mongodb+srv://&lt;username&gt;:&lt;password&gt;@xxxx.mongodb.net/yapi?retryWrites=trueconnectUser: adminconnectPass: xxxxx 3.3 推送代码在项目主页点击 Deploy，根据提示安装 Heroku CLI 并登录。123456# cd yapi# 修改 package.json -&gt; engines -&gt; node 为：\"&gt;= 7.6.0 &lt; 11\"# 因为项目使用了 node-sass. node-sass 的 linux 支持到此版本。heroku git:remote -a yapi-demogit push heroku dev:master --force# 等待服务器处理完成即可 3.4 验证部署打开 https://yapi-demo.herokuapp.com/（当然，你要替换成你自己的应用名）。首次加载可能很慢，有一个超大JS，需要加载一分钟左右（团队需要解决下）。使用先前的用户名和密码登录即可体验。 你也可以使用 demo@demo.com/demo 登录YApi Demo 体验，请勿修改密码。","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://mrzzcn.github.io/categories/Front-end/"}],"tags":[{"name":"Heroku","slug":"Heroku","permalink":"http://mrzzcn.github.io/tags/Heroku/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://mrzzcn.github.io/tags/mongoDB/"},{"name":"YApi","slug":"YApi","permalink":"http://mrzzcn.github.io/tags/YApi/"},{"name":"development","slug":"development","permalink":"http://mrzzcn.github.io/tags/development/"}]},{"title":"强化网站安全 - 第一篇：安全相关的Headers (Hardening Website Security – Part 1: HTTP Security Headers)","slug":"HTTP-Security-Headers","date":"2019-01-11","updated":"2019-04-27","comments":true,"path":"2019/01/11/HTTP-Security-Headers/","link":"","permalink":"http://mrzzcn.github.io/2019/01/11/HTTP-Security-Headers/","excerpt":"原文：Hardening Website Security – Part 1: HTTP Security Headers 简介感觉每周都会出现新的个人信息被盗事件，原因是某一家公司网站被黑了。 大部分攻击都是通过社会工程学诱骗某些用户主动提交一些信息，黑客借助这些信息获取更高权限并最终获取个人资料。 如果你想要在21世纪运营一个安全的网站，你需要遵循一些安全准则，我会写一个系列专栏说明这些安全准则，这是第一篇。","text":"原文：Hardening Website Security – Part 1: HTTP Security Headers 简介感觉每周都会出现新的个人信息被盗事件，原因是某一家公司网站被黑了。 大部分攻击都是通过社会工程学诱骗某些用户主动提交一些信息，黑客借助这些信息获取更高权限并最终获取个人资料。 如果你想要在21世纪运营一个安全的网站，你需要遵循一些安全准则，我会写一个系列专栏说明这些安全准则，这是第一篇。 本文不会介绍以下内容因为网络基础架构的安全配置内容太多（自托管或者VPS，OS，管理中台，防火墙等）而且细微差异众多，我不会在这个系列中介绍。我可能后面会专门写相关文章介绍那些内容。 免责声明 文章内容来自于我多年的工作经验、尝试，以及（频繁）犯错的总结。在正常经营的网站忽略HTTP headers 设置（极有）可能导致一些意外的甚至是灾难性的后果。本文所写内容都是个人依据自身知识水平总结的最佳实践，但是涉及到安全问题，我强烈建议读者在对你自己的系统或网站做任何改动之前确保你知道自己在干什么以及这么干的后果。本文所有的代码仅作示例展示，可能并不完善甚至有一些错误。读者从网页上拷贝粘贴使用代码时需要格外小心，这个网站也包含在内。Int64 Software Ltd公司所有员工与企业法人代表不对因故意或无意误用其帖子和文章中所提供信息而造成的损害承担任何责任。 概述当Web服务器接收一个标准的 HTTP Get 请求之后，它会把请求的资源和一些Header信息一起返回。这对于浏览器如何处理响应数据来说是必要的，比如资源的编码，内容长度等。 第一篇我们先来看一下安全相关的 Header有哪些，他们的作用以及如何设置他们。 配置服务器网站托管环境不同，设置Header的方法不同。下面是一些常用的比较流行的服务器软件/编程语言的Header配置方法。 Apache Web ServerApache的虚拟主机配置文件位于.htaccess 或.httpd.conf，使用以下指令设置：1Header set [HeaderName] [HeaderValue] Nginx在Nginx 的config 目录下，打开nginx.conf，添加以下内容：1add_header [HeaderName] \"[HeaderValue]\"; IIS(译者加: 在每个虚拟主机目录下)打开Web.Config文件，在&lt;system.webServer&gt;节点下添加&lt;customHeaders&gt;节点：12345&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=\"[HeaderName]\" value=\"[HeaderValue]\" /&gt; &lt;/customHeaders&gt;&lt;/httpProtocol&gt; PHPPHP 可以在文件顶部（在任意输出内容设置之前，包括空白）使用header 方法设置：1header('[HeaderName]: [HeaderValue]', true); 备注：一个请求只需要设置一次Header，不需要在每个包含的PHP文件里面配置。true 表示会覆盖已存在的同名 Header 。 Asp.Net在global.asax 文件增加以下代码：1234protected void Application_BeginRequest(object sender, EventArgs e)&#123; HttpContext.Current.Response.AddHeader(\"[HeaderName]\", \"[HeaderValue]\");&#125; HeadersX-Frame-OptionsX-Frame-Options用来防止 点击劫持，点击劫持指的是攻击者试图在用户浏览/使用网页过程中在诸如点击按钮等事件中执行一些非预期的操作。其中常见的一种攻击方式是 攻击者在他们自己的钓鱼网站上通过iframe 嵌入你的网页，然后在界面上覆盖一个透明的区域，用户以为在浏览你的网页，其实用户提交的信息已经被攻击者盗取。通过设置X-Frame-Options 你可以告诉浏览器当前网页不允许通过iframe 加载。该选项有三个可选值： DENY设置为DENY可以阻止任何其他网页通过iframe嵌入你的网页。除非你的网页明确需要被嵌入，否则请设置为这个值。 SAMEORIGIN设置为SAMEORIGIN会允许你自己的网站（同一域名），但是会阻止其他域（包括其他子域）嵌入你的网页。 ALLOW-FROM &lt;uri\\&gt;这种方式将阻止除指定URI以外的其他所有网页使用iframe加载当前网页(比如ALLOW-FROM https://myothersite.com)。 注意：该选项的浏览器支持性有限 推荐配置X-Frame-Options 应当总是设置为DENY，除非有明确的需要配置为其他值 其他说明X-Frame-Options 选项目前仍然被广泛支持，但是稍后即将讨论的CSP的frame-src选项可以替代这个功能。但是IE对CSP的支持从IE11 开始，而IE8以上已经支持X-Frame-Options，所以它仍然需要配置。 X-XSS-ProtectionX-XSS-Protection 被设计用于阻止跨站简本攻击(XSS)，X-XSS-Protection选项将开启浏览器的XSS过滤功能。XSS的攻击者通过注入恶意脚本（例如通过未经安全过滤的用户输入框）到网页，在用户浏览时影响网页正常展示或者偷取浏览者个人数据。最近有一起XSS攻击事件，攻击者通过脆弱的广告网络注入恶意脚本。攻击者有可能会把用户的付款信息转向他自己而不是用户所使用网页的提供者。X-XSS-Protection可以通知浏览器过滤并阻止XSS攻击进而降低安全风险，它有四种取值： 0.不启用（不推荐） 1.启用，如果检测到攻击代码，将会删除恶意代码并继续展示网页。通常是默认值。 1; mode=block启用，如果检测到攻击代码，将会阻止网页继续展示。 1; report=&lt;reporting-uri&gt;启用，如果检测到攻击代码，将会阻止并清理网页，然后向指定的uri报告恶意攻击事件。 推荐配置X-XSS-Protection应该设置为1，然后看情况开启block或report选项 其他说明与X-Frame-Options类似，CSP可以设置更强大和安全的策略，可以彻底禁止页面内联脚本的执行。稍后讨论。 X-Content-Type-OptionsX-Content-Type-Options只有一个取值nosniff，也只有一个目的：阻止浏览器使用Content-Type以外的类型处理当前内容。当浏览器收到一个文件之后，Content-Type会告诉浏览器这个文件的类型，浏览器自己也会使用多种技术做内容嗅探（或者媒体类型嗅探或MIME嗅探），搞清楚文件的具体类型然后相应处理。然后，在此过程中可能出现用户期望的文件类型与事实不符的情况，这有可能导致跨站脚本攻击或恶意软件分发。 推荐配置上面已经说了，应当总是设置X-Content-Type-Options为nosniff，阻止浏览器默认行为。 Strict-Transport-SecurityHTTP Strict Transport Security，通常简称为HSTS，用来通知浏览器使用安全的HTTPS连接而不是未加密的 HTTP 协议。有两种取值： max-age=&lt;MaxAgeInSeconds&gt;表示在未来的一段时间（单位为秒）内浏览器需要记住当前站点只能通过 HTTPS 访问。 includeSubDomains可选值，如果指定，表示当前站点的所有子域名也需要使用 HTTPS 连接访问 preload（译者加）可选值。谷歌维护着一个 HSTS 预加载服务。按照如下指示成功提交你的域名后，浏览器将会永不使用非安全的方式连接到你的域名。虽然该服务是由谷歌提供的，但所有浏览器都有使用这份列表的意向（或者已经在用了）。但是，这不是 HSTS 标准的一部分，也不该被当作正式的内容。 推荐配置Strict-Transport-Security 应当设置为稍微大一些的值例如1年（31536000 秒）。includeSubDomains选项可以看情况设置。1Strict-Transport-Security: max-age=31536000; includeSubDomains Content-Security-Policy最重要也最复杂的Header可能就是CSP，很多浏览器已经支持。如果配置得当，单一的CSP就可以为你的网站保驾护航。但是如果配置错误，也可能影响巨大。CSP的功能主要就是指示浏览器可以从哪里下载脚背以及服务器资源。一个CSP Header包含两部分：一个指令以及一个资源列表。指令指示当前设置的资源类型，资源列表限制当前指令可以下载的源。注意，CSP可以包含多个策略，你可以在一个Header里面通过分号(;)分隔多条指令，也可以设置多个CSP Header。比如，我想要配置JS文件从我们自己的服务器和一个JS 存储仓库(js.example.com)下载，样好似文件仅从我们自己的服务器下载，我可以通过单一Header 设置：1header(\"Content-Security-Policy: script-src 'self' js.example.com; style-src 'self';\", true); 或者通过多个Header 设置：12header(\"Content-Security-Policy: script-src 'self' js.example.com;\", false);header(\"Content-Security-Policy: style-src 'self';\", false); 注意最后一个参数表示替换已存在同名Header需要改为false，用来同时设置多个同名Header。 指令类型default-srcdefault-src 代表默认指令，如果正在请求的资源类型未明确定义，将会使用 default-src 策略。如果网页有图片请求，但是img-src没有配置，那么就会使用default-src的配置。 child-src(已弃用)之前用来配置 web workers 以及嵌套浏览器执行环境比如 iframe。然而，frames 和 workers 可能需要单独配置不同策略，这个选项已经被frame-src和worker-src取代。 connect-src限制脚本可以请求的源（a标签，pings，fetch，XMLHttpRequest，WebSocket，EventSource） font-src限制字体可以请求的源（Google Fonts等） frame-src限制&lt;frame&gt; 和 &lt;iframe&gt;可以加载的源 frame-ancestors限制当前页面可以被&lt;frame&gt; 和 &lt;iframe&gt;加载的源，设置为&#39;none&#39;效果与 X-Frame-Options: DENY 相同 img-src限制图片可以加载的源 manifest-src限制 Application manifest 文件可以加载的源 media-src限制媒体（&lt;audio&gt; , &lt;video&gt;, &lt;track&gt;）可以加载的源 object-src限制 &lt;object&gt;, &lt;embed&gt;, and &lt;applet&gt; 可以加载的源 prefech-src限制预请求或预渲染的源 script-src限制JS脚本的源。应当按需求配置为&#39;self&#39;以及可信的第三方CDN源。永远不要允许&#39;unsafe-inline&#39;，否则内联脚本的执行可能会导致XSS攻击，从而破坏整个CSP配置的功能。 style-src限制CSS样式的源 webrtc-src限制WebRTC(Web Real-Time Communications)可以连接的源 worker-src限制Worker/SharedWorker/ServiceWorker脚本的源 form-action限制表单提交的源 report-uri指定破坏CSP规则上报的uri block-all-mixed-content如果页面是通过HTTPS加载的，跳过所有HTTP资源请求 *允许所有data stream(blob:, data:, filesystem:)以外的源 ‘none’禁止当前资源类型从任意源加载 ‘self’当前页面所在源（同协议，同主机名，同端口） Data:数据流（例如base64 编码的图片地址） domain.example.com某一个指定域名 *.example.com某一个指定域名以及所有子域名 https://domain.example.com某一个指定域名并且只能通过HTTPS 连接 https:任意通过HTTPS连接的域名 ‘unsafe-inline’允许内联代码，包括内联样式或脚本块（请尽量避免使用） ‘unsafe-eval’允许javascripteval()方法 ‘nonce-&lt;noncevalue&gt;’可以在script/style标签上增加一个随机数，只有随机数与noncevalue匹配时，相应标签代码才可以执行。注意这个策略已经破解，可能不安全。 ‘sha256-&lt;hashvalue&gt;’script/style的SHA256哈希值与hashvalue匹配，相应代码才可以执行 推荐配置这一项很难有一个通用的确切值，因为需要根据每个网站具体配置。我的做法（在任何安全相关的问题）是尽可能把规则配的具体，然后找到冲突的点，解决冲突或者放松规则，直到所有的配置都正常工作。这里也可以这么做，但是请考虑以下情况：比如style-src，我们很容易就会配置为&#39;self&#39;策略，表示只能从本域加载 (.css) 文件。但你的代码里面可能会有少量内联样式，这时候怎么处理呢？最好是把这些内联样式都移到某一个文件里面，这并不总是可以很简单的完成，你可能会需要允许&#39;unsafe-inline&#39;。我觉得一个比较好的方式是通过一项项查看我的某个项目的CSP配置，说明一下我为什么这么配置，以及这么配置的负面影响。1default-src 'none'; 默认配置为拒绝所有未指定资源类型的任意加载源。考虑到我已经仔细检查了其他所有资源类型的加载策略，不应该有资源会回退到这个配置，如果有，那么这个资源一定不是由我添加的。注意：其他人在新增资源但是无法加载时可能来找你麻烦，因此很多人会设置为&#39;self&#39;。1script-src 'self' https://js.stripe.com; 所有的脚本都已经打包、压缩，因此不应该出现内联脚本，应当配置为&#39;self&#39;。另外，我使用 Stripe 作为支付网关，所以要允许 Stripe 的脚本库。1connect-src 'self' https://api.stripe.com; 我的应用大量使用Ajax请求，所以需要添加&#39;self&#39;。Stripe 也需要使用脚本请求接口，所以也添加了 Stripe 的服务域名。1img-src 'self' data:; 80年代的网页有一个明显的问题就是所有的图片都是由自己的服务器托管，所以需要&#39;self&#39;。当然，网页里面也会用到内联SVG图像，所以包含了&#39;data:&#39;。1style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; 样式主要都是自己服务器托管，少量使用 Google Fonts，所以添加了&#39;self&#39;和Google Fonts。很惭愧我（虽然很少但是偶尔会）也使用了页面内联样式，所以我添加了&#39;unsafe-inline&#39;。注意：已经有证据证明可以通过CSS注入读取表单信息，所以你需要额外注意使用这个策略可能导致的应用程序脆弱性。1font-src 'self' https://fonts.gstatic.com; 这个也相当简单，我要用到我们自己的和 Google 提供的字体，所以添加了&#39;self&#39;和Google的字体库。1frame-src 'self' https://*.stripe.com https://stripe.com; 这个略微有些复杂，Stripe 允许使用 3D Secure 保护卡的授权登录。不幸的是，对方推荐的实现方式是使用 Iframe（我也讨厌）。所以我这里添加 Stripe 作为支付网关，&#39;self&#39;做为授权完成之后 Iframe 的回跳地址。如果你也使用Stripe，你可能知道他们的文档说明只需要添加 https://js.stripe.com 作为 frame source，但是我操作的过程中发现一些问题，我正在与他们的技术支持团队合作把这个策略尽量收紧。1frame-ancestors 'none'; 之前已经提到，这项配置可以禁止当前网页被任何网站通过 Iframe 嵌入加载。注意：我在 3D Secure 的授权回跳页面上面把这项配置放送到&#39;self&#39;，这样我自己的网站才可以通过Iframe加载回跳页面。1report-uri /csp-report.php; 所有破坏CSP规则的异常都会被上报（由客户端浏览器）到这个地址，记录下来以后分析使用。1block-all-mixed-content; 最后，尽管我没有任何混合内容（译者：与页面协议不一致的加载方式，例如页面使用HTTPS，而某一图片使用HTTP），防止意外我还是添加了这条禁止策略。 其他指令的注意点： 绝大部分其他指令策略都会回退到 default-src 然后被禁止。有一个例外：worker-src 在很多浏览器（Chrome 59以上会忽略child-src直接回退到default-src, Edge 17 会忽略 script-src）中会回退到 child-src -&gt; script-src 。不设置 plugin-types 指令，在技术上会默认允许所有的扩展类型 (&lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;)，但同时我们没有配置 object-src，这项策略会降级到 default-src 从而在加载层面禁止所有的扩展。 代码示例Apache Web Server12345Header set X-Frame-Options \"SAMEORIGIN\"Header set X-XSS-Protection \"1; mode=block\"Header set X-Content-Type-Options \"nosniff\"Header set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"Header set Content-Security-Policy \"default-src 'none'; script-src 'self' https://js.stripe.com; connect-src 'self' https://api.stripe.com; img-src 'self' data:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https://*.stripe.com https://stripe.com; frame-ancestors 'none'; report-uri /csp_report.php; block-all-mixed-content;\" Nginx12345add_header X-Frame-Options \"SAMEORIGIN\"add_header X-XSS-Protection \"1; mode=block\"add_header X-Content-Type-Options \"nosniff\"add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\"add_header Content-Security-Policy \"default-src 'none'; script-src 'self' https://js.stripe.com; connect-src 'self' https://api.stripe.com; img-src 'self' data:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https://*.stripe.com https://stripe.com; frame-ancestors 'none'; report-uri /csp_report.php; block-all-mixed-content;\" IIS123456789&lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" /&gt; &lt;add name=\"X-XSS-Protection\" value=\"1; mode=block\" /&gt; &lt;add name=\"X-Content-Type-Options\" value=\"nosniff\" /&gt; &lt;add name=\"Strict-Transport-Security\" value=\"max-age=31536000; includeSubDomains\"/&gt; &lt;add name=\"Content-Security-Policy\" value=\"default-src 'none'; script-src 'self' https://js.stripe.com; connect-src 'self' https://api.stripe.com; img-src 'self' data:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https://*.stripe.com https://stripe.com; frame-ancestors 'none'; report-uri /csp_report.php; block-all-mixed-content;\" /&gt; &lt;/customHeaders&gt;&lt;/httpProtocol&gt; PHP1234567header('[HeaderName]: [HeaderValue]', true);header('X-Frame-Options: SAMEORIGIN');header('X-XSS-Protection: 1; mode=block');header('X-Content-Type-Options: nosniff');header('Strict-Transport-Security: max-age=31536000; includeSubDomains');header('Content-Security-Policy: default-src \\'none\\'; script-src \\'self\\' https://js.stripe.com; connect-src \\'self\\' https://api.stripe.com; img-src \\'self\\' data:; style-src \\'self\\' \\'unsafe-inline\\' https://fonts.googleapis.com; font-src \\'self\\' https://fonts.gstatic.com; frame-src \\'self\\' https://*.stripe.com https://stripe.com; frame-ancestors \\'none\\'; report-uri /csp_report.php; block-all-mixed-content;'); ASP.NET123456789protected void Application_BeginRequest(object sender, EventArgs e)&#123; HttpContext.Current.Response.AddHeader(\"X-Frame-Options\", \"SAMEORIGIN\"); HttpContext.Current.Response.AddHeader(\"X-XSS-Protection\", \"1; mode=block\"); HttpContext.Current.Response.AddHeader(\"X-Content-Type-Options\", \"nosniff\"); HttpContext.Current.Response.AddHeader(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\"); HttpContext.Current.Response.AddHeader(\"Content-Security-Policy\", \"default-src 'none'; script-src 'self' https://js.stripe.com; connect-src 'self' https://api.stripe.com; img-src 'self' data:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https://*.stripe.com https://stripe.com; frame-ancestors 'none'; report-uri /csp_report.php; block-all-mixed-content;\");&#125; 下集预告请先阅读有关使用 HSTS Preloading 的附录，然后继续阅读第二篇：Cookie攻防实战。关注作者：Twitter译者微薄：新浪微博 刊误如果你有任何意见或建议，请联系：support@int64software.com 。译者邮箱：mrzzcn@gmail.com 。","categories":[{"name":"Translate","slug":"Translate","permalink":"http://mrzzcn.github.io/categories/Translate/"},{"name":"Technology","slug":"Translate/Technology","permalink":"http://mrzzcn.github.io/categories/Translate/Technology/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://mrzzcn.github.io/tags/Web/"},{"name":"HTTP","slug":"HTTP","permalink":"http://mrzzcn.github.io/tags/HTTP/"},{"name":"Headers","slug":"Headers","permalink":"http://mrzzcn.github.io/tags/Headers/"},{"name":"Security","slug":"Security","permalink":"http://mrzzcn.github.io/tags/Security/"}]},{"title":"BFC","slug":"bfc","date":"2018-12-28","updated":"2019-04-27","comments":true,"path":"2018/12/28/bfc/","link":"","permalink":"http://mrzzcn.github.io/2018/12/28/bfc/","excerpt":"1. 含义 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 下列方式会创建块格式化上下文： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。","text":"1. 含义 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 下列方式会创建块格式化上下文： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 块格式化上下文包含创建它的元素内部的所有内容. 块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。– MDN 戳此查看 2. 应用同一个 BFC 下外边距会发生折叠See the Pen aPyrXL by Jack (@zhangzhen) on CodePen. 前两个元素（1-1 1-2）位于同一个BFC内部，所以上边元素的 margin-bottom 与 下边元素的 margin-top 发生坍缩，坍缩的结果为最终的 margin 值是两者中的较大值.后两个元素（2-1 3-1）位于不同BFC内部，所以没有发生坍缩，最终 margin 等于上边元素的 margin-bottom 加下边元素的 margin-top 包含浮动的元素（清除浮动）See the Pen BFC 可以包含浮动的元素（清除浮动） by Jack (@zhangzhen) on CodePen. 上方容器Parent 1内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素（Parent 2）。 阻止元素被浮动元素覆盖See the Pen BFC 可以阻止元素被浮动元素覆盖 by Jack (@zhangzhen) on CodePen. 上边的布局是一个常见的图文混排的模版，但是有时候我们不需要这种布局，我们期望一个左右布局的页面，如下边的Demo展示的这种，就可以通过触发下面元素的 BFC 来实现。 这个方法来实现两列自适应布局，左边宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 当然也可以用来实现多列布局，也是相当方便。 3. (*)FCFC 即 Formatting Contexts，包含：IFC、BFC、GFC 与 FFC 。FC是网页CSS视觉渲染的一部分，用于决定盒子模型的布局、其子元素将如何定位以及和其他元素的关系和相互作用。其中：IFC（Inline Formatting Contexts）与 BFC（Block Formatting Contexts）是 CSS2.1 规范中引进的；后面两个是 CSS3 新增规范，GFC（GridLayout Formatting Contexts）以及 FFC（Flex Formatting Context）。 关于这几个 FC 的具体区别可参考：https://github.com/chokcoco/iCSS/issues/5 参考链接https://zhuanlan.zhihu.com/p/25321647https://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/https://github.com/chokcoco/iCSS/issues/5","categories":[{"name":"Technology","slug":"Technology","permalink":"http://mrzzcn.github.io/categories/Technology/"},{"name":"CSS","slug":"Technology/CSS","permalink":"http://mrzzcn.github.io/categories/Technology/CSS/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://mrzzcn.github.io/tags/随笔/"},{"name":"CSS","slug":"CSS","permalink":"http://mrzzcn.github.io/tags/CSS/"},{"name":"BFC","slug":"BFC","permalink":"http://mrzzcn.github.io/tags/BFC/"}]},{"title":"[翻译]Arrow Functions in Class Properties Might Not Be As Great As We Think","slug":"arrow-function-in-class-property","date":"2018-11-17","updated":"2019-04-27","comments":true,"path":"2018/11/17/arrow-function-in-class-property/","link":"","permalink":"http://mrzzcn.github.io/2018/11/17/arrow-function-in-class-property/","excerpt":"Javascript 新增了 arrow function 和 class，这两者的概念可参考：arrow function，类。React 里面的方法想要在JSX中使用，必须手动绑定 this，有些人会在这儿使用箭头函数简写掉 this.method = this.method.bind(this); 这行代码，本文作者对这种写法进行了分析，原文在此：Arrow Functions in Class Properties Might Not Be As Great As We Think","text":"Javascript 新增了 arrow function 和 class，这两者的概念可参考：arrow function，类。React 里面的方法想要在JSX中使用，必须手动绑定 this，有些人会在这儿使用箭头函数简写掉 this.method = this.method.bind(this); 这行代码，本文作者对这种写法进行了分析，原文在此：Arrow Functions in Class Properties Might Not Be As Great As We Think 自2016年以来， Class Properties Proposal 让我们的代码简洁了许多，特别是在 React 的 state 书写或者在声明静态成员 propTypes 和 defaultProps 的时候。看下代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041// Class properties 以前class Greeting extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isLoading: false &#125;; &#125; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;Greeting.protoTypes = &#123; name: ProtoTypes.String.Required&#125;;Greeting.defaultProps = &#123; name: 'Stranger'&#125;;// Class properties 之后class Greeting extends Component &#123; static protoTypes = &#123; name: ProtoTypes.String.Required &#125;; static defaultProps = &#123; name: 'Stranger' &#125;; state = &#123; isLoading: false &#125;; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 另外，在 React 里面需要处理this绑定的时候，直接以属性声明而不再使用 constructor 赋值方式在过去的几个月里面也越来越成为一种趋势。Twitter链接12345678910// Usage example of arrow function in a class property.class ComponentA extends Component &#123; handleClick = () =&gt; &#123; // ... &#125; render() &#123; // ... &#125;&#125; 箭头函数在声明属性时候很方便，自动绑定 this，不需要在 constructor 里添加 this.handleClick = this.handleClick.bind(this).但是，我们真的可以这么用吗？首先来看一下类属性究竟是怎么实现自动绑定的： 箭头函数是怎么编译到ES2017的编写一个包含静态属性，实例属性，箭头函数属性，另外一个常见成员方法的类，使用 transform-class-properties 插件编译.123456789101112class A &#123; static color = \"red\"; counter = 0; handleClick = () =&gt; &#123; this.counter++; &#125; handleLongClick() &#123; this.counter++; &#125;&#125; 使用 Babel REPL 编译这个类到ES2017 格式，编译插件：es2017 stage-2，我们得到以下代码： 打开 Babel 里面查看代码时如果编译出错，请在左下角添加 Plugin ： babel-plugin-transform-class-properties 1234567891011121314class A &#123; constructor() &#123; this.counter = 0; this.handleClick = () =&gt; &#123; this.counter++; &#125;; &#125; handleLongClick() &#123; this.counter++; &#125;&#125;A.color = \"red\"; 有兴趣的同学可以看一下：点击查看 我们可以看到， 实例属性被移动到 constructor 内部，静态成员被移动到类声明完成之后static 关键字可以省略额外的静态属性声明代码，然后可以直接export class XXX extends Component，个人比较喜欢这点实例属性表现也不错，在没有编译的版本中，类声明简洁了许多但是，箭头函数声明的属性 handleClick 也被移动到了 constructor，与普通的实例属性类似正常的成员方法 handleLongClick 没有改变属性自动初始化对于正常的属性没有问题，但是使用箭头函数声明的属性，属于Hack得到一个 this 绑定你有没有发现问题？我们来看下我的发现 Mockability如果我们想要 mock 一个类的某一个方法， 最简单的方式就是修改 prototype，这会对这个类原型链上所有的对象生效我们看下使用这种方式测试之前的类 A 会发生什么：我们继续把之前的类 A 编译到 ES2015: 点击查看12345678910111213141516171819202122232425262728293031323334353637383940414243class A &#123; static color = \"red\"; counter = 0; handleClick = () =&gt; &#123; this.counter++; &#125; handleLongClick() &#123; this.counter++; &#125;&#125;// 编译输出\"use strict\";function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var A = (function() &#123; function A() &#123; var _this = this; _classCallCheck(this, A); this.counter = 0; this.handleClick = function() &#123; _this.counter++; &#125;; &#125; A.prototype.handleLongClick = function handleLongClick() &#123; this.counter++; &#125;; return A;&#125;)();A.color = \"red\"; A.prototype.handleLongClick 有效.A.prototype.handleClick 未定义. 叮~， 使用箭头函数定义的 handleClick 编译之后被移动到构造函数里面使用实例声明，而不是类方法。所以，我们在实例上 Mock 这种方式定义的方法，这些更改无法同步到其他对象。 Inheritance首先定义 class A .123456789101112131415161718class A &#123; handleClick = () =&gt; &#123; console.log(\"A.handleClick\"); &#125; handleLongClick() &#123; console.log(\"A.handleLongClick\"); &#125;&#125;console.log(A.prototype);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new A().handleClick();// A.handleClicknew A().handleLongClick();// A.handleLongClick 如果 class B 继承 class A，由于 handleClick 是不在 prototype 上定义的，class B 内部无法通过 super.handleClick 调用父类方法1234567891011121314151617181920212223242526class B extends A &#123; handleClick = () =&gt; &#123; super.handleClick(); console.log(\"B.handleClick\"); &#125; handleLongClick() &#123; super.handleLongClick(); console.log(\"B.handleLongClick\"); &#125;&#125;console.log(B.prototype);// A &#123;constructor: ƒ, handleLongClick: ƒ&#125;console.log(B.prototype.__proto__);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new B().handleClick();// Uncaught TypeError: (intermediate value).handleClick is not a functionnew B().handleLongClick();// A.handleLongClick// B.handleLongClick class C 继承 class A，但是使用类成员而不是箭头函数重新实现了 handleClick 方法，这时 handleClick 将只会执行 super.handleClick, 而不会执行自己定义的代码（只执行父类定义的方法），奇怪了？ 这时因为父类的构造函数重写了handleClick方法。 C.prototype.handleClick()会调用class C的 handleClick方法，但是会报错: Uncaught TypeError: (intermediate value).handleClick is not a function .12345678910111213141516class C extends A &#123; handleClick() &#123; super.handleClick(); console.log(\"C.handleClick\"); &#125;&#125;console.log(C.prototype);// A &#123;constructor: ƒ, handleClick: ƒ&#125;console.log(C.prototype.__proto__);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new C().handleClick();// A.handleClick 感兴趣的同学可以点击链接查看原因。 class D 以字面量对象方式继承 class A，D 将拥有一个空的 prototype，new D().handleClick() 会打印 A.handleClick:12345678910class D extends A &#123;&#125;console.log(D.prototype);// A &#123;constructor: ƒ&#125;console.log(D.prototype.__proto__);// &#123;constructor: ƒ, handleLongClick: ƒ&#125;new D().handleClick();// A.handleClick Performance现在我们来看一下比较有趣的部分：性能 我们知道方法通常都是定义在原型上面，这样定义的方法会在所有实例上共享. 一个组件列表里面的所有组件都分享相同的方法. 列表里面的每个组件被点击, 都会执行点击事件, 但是无论哪个组件点击都是调用原型链上同一个方法. 因为是同一个方法多次调用, JS引擎会优化这个方法. 与此相对, 类中箭头函数定义的方法, 在多个组件实例中会创建多个方法. 还记得刚才我们看到的编译输出吗, 箭头函数成员在构造方法中声明. 每个组件被点击, 执行的都是不同的方法. 我们看下在V8 Engine(Chrome)下二者的表现差异: 第一个测试比较简单, 只测试初始化时间, 然后调用方法一次. 注意这个测试中数字并不重要, 因为单个实例化过程在应用程序中无关大碍, 我们讨论的是每秒能执行多少次操作并且频率足够高. 我比较担心方法之间的差异. For the second one, I used a representative use case. The instantiation of 100 components — like a list — which after we called the method one time on each. 第二个测试, 使用一个比较有代表性的使用示例. 初始化100个组件形成一个组件列表, 对每个组件调用一次方法. All benchmarks were run on a MacBook Pro 13” 2016 2GHz on Mac OS X 10.13.1 and Chrome 62.0.3202. 总的来说, 为了更好的代码执行性能, 我们需要在原型上声明方法然后在需要时bind到实例上(当作属性或者回调函数传递). 在原型上声明方法并在构造方法中声明并绑定自己的属性是有意义的, 而且方法并不是特别多.我们讨论的是高频操作, 但是我们清楚看到箭头函数在类声明中性能表现并不是我们期待的情况.有人会说这点儿性能损失并无大碍, 我们绝大多数情况并不会对一个组件声明很多实例, 的确这样.你也可以认为这是一个提前优化(提前优化是万恶之源), 但是, 我们能把箭头函数在类属性中的使用当作简化使用还是不当使用呢? 希望JS引擎将来会优化类属性中的箭头函数. P.S: Class properties for properties are such a great improvement! 我在很多应用程序和软件包中都见到过这类使用方式, 很多可以多实例方式使用的组件也是. 既然已经知道这种方式现在会影响程序性能, 我们真的应该继续使用吗? 我个人认为这是一个牺牲性能, 而且并不总是那么好用的做法. 解决方案是 autobind-decorator, 不幸的是当前只能借助babel 使用, 它还只是一个stage 2的提案.12345678910class Component &#123; constructor(value) &#123; this.value = value; &#125; @autobind method() &#123; return this.value; &#125;&#125; 尽管如此, 他们也建议最好不要滥用 autobind: It is unnecessary to do that to every function. This is just as bad as autobinding (on a class). You only need to bind functions that you pass around. e.g. onClick={this.doSomething}. Or fetch.then(this.hanldeDone) — Dan Abramov. ‏I was the guy who came up with autobinding in older Reacts and I’m glad to see it gone. It might save you a few keystrokes but it allocates functions that’ll never be called in 90% of cases and has noticeable performance degradation. Getting rid of autobinding is a good thing — Peter Hunt Conclusion使用箭头函数声明的类成员会被编译到构造函数中定义到当前对象上面而不是在当前类的原型上. 我们无法使用super调用这些方法. 箭头函数声明类属性比绑定方法慢很多, 它们都比正常方法要慢. 我们只需要.bind()可能会被传递的方法. 知道箭头函数声明的类属性是如何工作以及真实的性能表现之后, 你应该可以做出聪明的选择并清楚这些选择的结果.你觉得呢? 你会继续这么使用吗? 这篇文章会不会让你改变想法?欢迎交流想法.","categories":[{"name":"Translate","slug":"Translate","permalink":"http://mrzzcn.github.io/categories/Translate/"},{"name":"Technology","slug":"Translate/Technology","permalink":"http://mrzzcn.github.io/categories/Translate/Technology/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://mrzzcn.github.io/tags/随笔/"},{"name":"Javascript","slug":"Javascript","permalink":"http://mrzzcn.github.io/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://mrzzcn.github.io/tags/React/"},{"name":"ES6","slug":"ES6","permalink":"http://mrzzcn.github.io/tags/ES6/"},{"name":"Class","slug":"Class","permalink":"http://mrzzcn.github.io/tags/Class/"},{"name":"Arrow functions","slug":"Arrow-functions","permalink":"http://mrzzcn.github.io/tags/Arrow-functions/"}]},{"title":"core-js ES6 ES7 cheatsheet","slug":"core-js-es","date":"2018-04-27","updated":"2019-04-27","comments":true,"path":"2018/04/27/core-js-es/","link":"","permalink":"http://mrzzcn.github.io/2018/04/27/core-js-es/","excerpt":"ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。 ECMAScript 6 (ES2015/ES6) / ECMAScript 2015 (ES2015)：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅这张兼容性表来查看不同浏览器和工具的实现情况。 ECMAScript 2016 (ES2016/ES7)：第七版 ECMAScript 修订. ECMAScript 2017 (ES2017) 对常用的API作个简单说明(按需引入polyfill), 点此查看Github链接原文","text":"ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。 ECMAScript 6 (ES2015/ES6) / ECMAScript 2015 (ES2015)：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅这张兼容性表来查看不同浏览器和工具的实现情况。 ECMAScript 2016 (ES2016/ES7)：第七版 ECMAScript 修订. ECMAScript 2017 (ES2017) 对常用的API作个简单说明(按需引入polyfill), 点此查看Github链接原文下文中. 表示类方法/属性, # 表示实例方法/属性ES5: All features moved to the es6 namespace, here just a list of features:1234567891011121314151617181920212223242526272829303132333435363738394041424344Object .create(proto | null, descriptors?) -&gt; object .getPrototypeOf(object) -&gt; proto | null .defineProperty(target, key, desc) -&gt; target, cap for ie8- .defineProperties(target, descriptors) -&gt; target, cap for ie8- .getOwnPropertyDescriptor(object, key) -&gt; desc .getOwnPropertyNames(object) -&gt; array .keys(object) -&gt; array .seal(object) -&gt; object, cap for ie8- .freeze(object) -&gt; object, cap for ie8- .preventExtensions(object) -&gt; object, cap for ie8- .isSealed(object) -&gt; bool, cap for ie8- .isFrozen(object) -&gt; bool, cap for ie8- .isExtensible(object) -&gt; bool, cap for ie8-Array .isArray(var) -&gt; bool #slice(start?, end?) -&gt; array, fix for ie7- #join(string = ',') -&gt; string, fix for ie7- #indexOf(var, from?) -&gt; int #lastIndexOf(var, from?) -&gt; int #every(fn(val, index, @), that) -&gt; bool #some(fn(val, index, @), that) -&gt; bool #forEach(fn(val, index, @), that) -&gt; void #map(fn(val, index, @), that) -&gt; array #filter(fn(val, index, @), that) -&gt; array #reduce(fn(memo, val, index, @), memo?) -&gt; var #reduceRight(fn(memo, val, index, @), memo?) -&gt; var #sort(fn?) -&gt; @, fixes for some enginesFunction #bind(object, ...args) -&gt; boundFn(...args)String #split(separator, limit) -&gt; array #trim() -&gt; strRegExp #toString() -&gt; strNumber #toFixed(digits) -&gt; string #toPrecision(precision) -&gt; stringparseInt(str, radix) -&gt; intparseFloat(str) -&gt; numDate .now() -&gt; int #toISOString() -&gt; string #toJSON() -&gt; string ES6: Object123456789101112131415161718Object .assign(target, ...src) -&gt; target .is(a, b) -&gt; bool .setPrototypeOf(target, proto | null) -&gt; target (required __proto__ - IE11+) .create(object | null, descriptors?) -&gt; object .getPrototypeOf(var) -&gt; object | null .defineProperty(object, key, desc) -&gt; target .defineProperties(object, descriptors) -&gt; target .getOwnPropertyDescriptor(var, key) -&gt; desc | undefined .keys(var) -&gt; array .getOwnPropertyNames(var) -&gt; array .freeze(var) -&gt; var .seal(var) -&gt; var .preventExtensions(var) -&gt; var .isFrozen(var) -&gt; bool .isSealed(var) -&gt; bool .isExtensible(var) -&gt; bool #toString() -&gt; string, ES6 fix: @@toStringTag support ES6: Function1234Function #bind(object, ...args) -&gt; boundFn(...args) #name -&gt; string (IE9+) #@@hasInstance(var) -&gt; bool ES6: Array123456789101112131415161718192021222324252627Array .from(iterable | array-like, mapFn(val, index)?, that) -&gt; array .of(...args) -&gt; array .isArray(var) -&gt; bool #copyWithin(target = 0, start = 0, end = @length) -&gt; @ #fill(val, start = 0, end = @length) -&gt; @ #find(fn(val, index, @), that) -&gt; val #findIndex(fn(val, index, @), that) -&gt; index | -1 #values() -&gt; iterator #keys() -&gt; iterator #entries() -&gt; iterator #join(string = ',') -&gt; string, fix for ie7- #slice(start?, end?) -&gt; array, fix for ie7- #indexOf(var, from?) -&gt; index | -1 #lastIndexOf(var, from?) -&gt; index | -1 #every(fn(val, index, @), that) -&gt; bool #some(fn(val, index, @), that) -&gt; bool #forEach(fn(val, index, @), that) -&gt; void #map(fn(val, index, @), that) -&gt; array #filter(fn(val, index, @), that) -&gt; array #reduce(fn(memo, val, index, @), memo?) -&gt; var #reduceRight(fn(memo, val, index, @), memo?) -&gt; var #sort(fn?) -&gt; @, invalid arguments fix #@@iterator() -&gt; iterator (values) #@@unscopables -&gt; object (cap)Arguments #@@iterator() -&gt; iterator (values, available only in core-js methods) ES6: String1234567891011121314151617181920212223String .fromCodePoint(...codePoints) -&gt; str .raw(&#123;raw&#125;, ...substitutions) -&gt; str #includes(str, from?) -&gt; bool #startsWith(str, from?) -&gt; bool #endsWith(str, from?) -&gt; bool #repeat(num) -&gt; str #codePointAt(pos) -&gt; uint #trim() -&gt; str, ES6 fix #anchor(name) -&gt; str #big() -&gt; str #blink() -&gt; str #bold() -&gt; str #fixed() -&gt; str #fontcolor(color) -&gt; str #fontsize(size) -&gt; str #italics() -&gt; str #link(url) -&gt; str #small() -&gt; str #strike() -&gt; str #sub() -&gt; str #sup() -&gt; str #@@iterator() -&gt; iterator (code points) ES6: RegExp123456789101112[new] RegExp(pattern, flags?) -&gt; regexp, ES6 fix: can alter flags (IE9+) #flags -&gt; str (IE9+) #toString() -&gt; str, ES6 fixes #@@match(str) -&gt; array | null #@@replace(str, replacer) -&gt; string #@@search(str) -&gt; index #@@split(str, limit) -&gt; arrayString #match(tpl) -&gt; var, ES6 fix for support @@match #replace(tpl, replacer) -&gt; var, ES6 fix for support @@replace #search(tpl) -&gt; var, ES6 fix for support @@search #split(tpl, limit) -&gt; var, ES6 fix for support @@split, some fixes for old engines ES6: Number1234567891011121314[new] Number(var) -&gt; number | number object .isFinite(num) -&gt; bool .isNaN(num) -&gt; bool .isInteger(num) -&gt; bool .isSafeInteger(num) -&gt; bool .parseFloat(str) -&gt; num .parseInt(str) -&gt; int .EPSILON -&gt; num .MAX_SAFE_INTEGER -&gt; int .MIN_SAFE_INTEGER -&gt; int #toFixed(digits) -&gt; string, fixes #toPrecision(precision) -&gt; string, fixesparseFloat(str) -&gt; num, fixesparseInt(str) -&gt; int, fixes ES6: Math123456789101112131415161718Math .acosh(num) -&gt; num .asinh(num) -&gt; num .atanh(num) -&gt; num .cbrt(num) -&gt; num .clz32(num) -&gt; uint .cosh(num) -&gt; num .expm1(num) -&gt; num .fround(num) -&gt; num .hypot(...args) -&gt; num .imul(num, num) -&gt; int .log1p(num) -&gt; num .log10(num) -&gt; num .log2(num) -&gt; num .sign(num) -&gt; 1 | -1 | 0 | -0 | NaN .sinh(num) -&gt; num .tanh(num) -&gt; num .trunc(num) -&gt; num ES6: Date123456Date .now() -&gt; int #toISOString() -&gt; string #toJSON() -&gt; string #toString() -&gt; string #@@toPrimitive(hint) -&gt; primitive ES6: Promise1234567new Promise(executor(resolve(var), reject(var))) -&gt; promise #then(resolved(var), rejected(var)) -&gt; promise #catch(rejected(var)) -&gt; promise .resolve(promise | var) -&gt; promise .reject(var) -&gt; promise .all(iterable) -&gt; promise .race(iterable) -&gt; promise ES6: Collections1234567891011121314151617181920212223242526272829303132333435new Map(iterable (entries) ?) -&gt; map #clear() -&gt; void #delete(key) -&gt; bool #forEach(fn(val, key, @), that) -&gt; void #get(key) -&gt; val #has(key) -&gt; bool #set(key, val) -&gt; @ #size -&gt; uint #values() -&gt; iterator #keys() -&gt; iterator #entries() -&gt; iterator #@@iterator() -&gt; iterator (entries) new Set(iterable?) -&gt; set #add(key) -&gt; @ #clear() -&gt; void #delete(key) -&gt; bool #forEach(fn(el, el, @), that) -&gt; void #has(key) -&gt; bool #size -&gt; uint #values() -&gt; iterator #keys() -&gt; iterator #entries() -&gt; iterator #@@iterator() -&gt; iterator (values) new WeakMap(iterable (entries) ?) -&gt; weakmap #delete(key) -&gt; bool #get(key) -&gt; val #has(key) -&gt; bool #set(key, val) -&gt; @new WeakSet(iterable?) -&gt; weakset #add(key) -&gt; @ #delete(key) -&gt; bool #has(key) -&gt; bool ES6: Symbol123456789101112131415161718Symbol(description?) -&gt; symbol .hasInstance -&gt; @@hasInstance .isConcatSpreadable -&gt; @@isConcatSpreadable .iterator -&gt; @@iterator .match -&gt; @@match .replace -&gt; @@replace .search -&gt; @@search .species -&gt; @@species .split -&gt; @@split .toPrimitive -&gt; @@toPrimitive .toStringTag -&gt; @@toStringTag .unscopables -&gt; @@unscopables .for(key) -&gt; symbol .keyFor(symbol) -&gt; key .useSimple() -&gt; void .useSetter() -&gt; voidObject .getOwnPropertySymbols(object) -&gt; array ES6: Typed Arrays123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475new ArrayBuffer(length) -&gt; buffer .isView(var) -&gt; bool #slice(start = 0, end = @length) -&gt; buffer #byteLength -&gt; uintnew DataView(buffer, byteOffset = 0, byteLength = buffer.byteLength - byteOffset) -&gt; view #getInt8(offset) -&gt; int8 #getUint8(offset) -&gt; uint8 #getInt16(offset, littleEndian = false) -&gt; int16 #getUint16(offset, littleEndian = false) -&gt; uint16 #getInt32(offset, littleEndian = false) -&gt; int32 #getUint32(offset, littleEndian = false) -&gt; uint32 #getFloat32(offset, littleEndian = false) -&gt; float32 #getFloat64(offset, littleEndian = false) -&gt; float64 #setInt8(offset, value) -&gt; void #setUint8(offset, value) -&gt; void #setInt16(offset, value, littleEndian = false) -&gt; void #setUint16(offset, value, littleEndian = false) -&gt; void #setInt32(offset, value, littleEndian = false) -&gt; void #setUint32(offset, value, littleEndian = false) -&gt; void #setFloat32(offset, value, littleEndian = false) -&gt; void #setFloat64(offset, value, littleEndian = false) -&gt; void #buffer -&gt; buffer #byteLength -&gt; uint #byteOffset -&gt; uint&#123; Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array&#125; new %TypedArray%(length) -&gt; typed new %TypedArray%(typed) -&gt; typed new %TypedArray%(arrayLike) -&gt; typed new %TypedArray%(iterable) -&gt; typed new %TypedArray%(buffer, byteOffset = 0, length = (buffer.byteLength - byteOffset) / @BYTES_PER_ELEMENT) -&gt; typed .BYTES_PER_ELEMENT -&gt; uint .from(arrayLike | iterable, mapFn(val, index)?, that) -&gt; typed .of(...args) -&gt; typed #BYTES_PER_ELEMENT -&gt; uint #copyWithin(target = 0, start = 0, end = @length) -&gt; @ #every(fn(val, index, @), that) -&gt; bool #fill(val, start = 0, end = @length) -&gt; @ #filter(fn(val, index, @), that) -&gt; typed #find(fn(val, index, @), that) -&gt; val #findIndex(fn(val, index, @), that) -&gt; index #forEach(fn(val, index, @), that) -&gt; void #indexOf(var, from?) -&gt; int #join(string = ',') -&gt; string #lastIndexOf(var, from?) -&gt; int #map(fn(val, index, @), that) -&gt; typed #reduce(fn(memo, val, index, @), memo?) -&gt; var #reduceRight(fn(memo, val, index, @), memo?) -&gt; var #reverse() -&gt; @ #set(arrayLike, offset = 0) -&gt; void #slice(start = 0, end = @length) -&gt; typed #some(fn(val, index, @), that) -&gt; bool #sort(fn(a, b)?) -&gt; @ #subarray(start = 0, end = @length) -&gt; typed #toString() -&gt; string #toLocaleString() -&gt; string #values() -&gt; iterator #keys() -&gt; iterator #entries() -&gt; iterator #@@iterator() -&gt; iterator (values) #buffer -&gt; buffer #byteLength -&gt; uint #byteOffset -&gt; uint #length -&gt; uint ES6: Reflect123456789101112131415Reflect .apply(target, thisArgument, argumentsList) -&gt; var .construct(target, argumentsList, newTarget?) -&gt; object .defineProperty(target, propertyKey, attributes) -&gt; bool .deleteProperty(target, propertyKey) -&gt; bool .enumerate(target) -&gt; iterator (removed from the spec and will be removed from core-js@3) .get(target, propertyKey, receiver?) -&gt; var .getOwnPropertyDescriptor(target, propertyKey) -&gt; desc .getPrototypeOf(target) -&gt; object | null .has(target, propertyKey) -&gt; bool .isExtensible(target) -&gt; bool .ownKeys(target) -&gt; array .preventExtensions(target) -&gt; bool .set(target, propertyKey, V, receiver?) -&gt; bool .setPrototypeOf(target, proto) -&gt; bool (required __proto__ - IE11+) ES7: Stage 4 proposals1234567891011121314151617181920212223242526272829Array #includes(var, from?) -&gt; bool&#123; Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array&#125; #includes(var, from?) -&gt; bool Object .values(object) -&gt; array .entries(object) -&gt; array .getOwnPropertyDescriptors(object) -&gt; object String #padStart(length, fillStr = ' ') -&gt; string #padEnd(length, fillStr = ' ') -&gt; string Object #__defineSetter__(key, fn) -&gt; void #__defineGetter__(key, fn) -&gt; void #__lookupSetter__(key) -&gt; fn | void #__lookupGetter__(key) -&gt; fn | void ES7: Stage 3 proposals1234567891011global -&gt; objectSystem .global -&gt; object (obsolete)global.Array === Array; // =&gt; truePromise #finally(onFinally()) -&gt; promise Symbol .asyncIterator -&gt; @@asyncIterator ES7: Stage 2 proposals12345String #trimLeft() -&gt; string #trimRight() -&gt; string #trimStart() -&gt; string #trimEnd() -&gt; string ES7: Stage 1 proposals1234567891011121314151617181920212223242526272829303132333435363738394041424344Promise .try(function()) -&gt; promiseArray #flatten(depthArg = 1) -&gt; array #flatMap(fn(val, key, @), that) -&gt; arraySet .of(...args) -&gt; set .from(iterable, mapFn(val, index)?, that?) -&gt; setMap .of(...args) -&gt; map .from(iterable, mapFn(val, index)?, that?) -&gt; mapWeakSet .of(...args) -&gt; weakset .from(iterable, mapFn(val, index)?, that?) -&gt; weaksetWeakMap .of(...args) -&gt; weakmap .from(iterable, mapFn(val, index)?, that?) -&gt; weakmap String #matchAll(regexp) -&gt; iterator new Observable(fn) -&gt; observable #subscribe(observer) -&gt; subscription #forEach(fn) -&gt; promise #@@observable() -&gt; @ .of(...items) -&gt; observable .from(observable | iterable) -&gt; observable .@@species -&gt; @Symbol .observable -&gt; @@observable Math .DEG_PER_RAD -&gt; number .RAD_PER_DEG -&gt; number .clamp(x, lower, upper) -&gt; number .degrees(radians) -&gt; number .fscale(x, inLow, inHigh, outLow, outHigh) -&gt; number .radians(degrees) -&gt; number .scale(x, inLow, inHigh, outLow, outHigh) -&gt; number Math .signbit(x) -&gt; bool …ES7: Stage 0 proposals and below","categories":[{"name":"Technology","slug":"Technology","permalink":"http://mrzzcn.github.io/categories/Technology/"},{"name":"Javascript","slug":"Technology/Javascript","permalink":"http://mrzzcn.github.io/categories/Technology/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzzcn.github.io/tags/Javascript/"},{"name":"core-js","slug":"core-js","permalink":"http://mrzzcn.github.io/tags/core-js/"},{"name":"babel","slug":"babel","permalink":"http://mrzzcn.github.io/tags/babel/"},{"name":"es6","slug":"es6","permalink":"http://mrzzcn.github.io/tags/es6/"},{"name":"es7","slug":"es7","permalink":"http://mrzzcn.github.io/tags/es7/"}]},{"title":"Git 工作流","slug":"git-flow","date":"2015-11-17","updated":"2019-04-27","comments":true,"path":"2015/11/17/git-flow/","link":"","permalink":"http://mrzzcn.github.io/2015/11/17/git-flow/","excerpt":"简单整理一下多人同一远程仓库git工作流模式。 1. 初始化本地仓库12345// 已有项目git clone git@github.com:mrzzcn/mrzzcn.github.io.git// 新建项目git init","text":"简单整理一下多人同一远程仓库git工作流模式。 1. 初始化本地仓库12345// 已有项目git clone git@github.com:mrzzcn/mrzzcn.github.io.git// 新建项目git init 2. 分支三个基本分支：master: 稳定分支，用于发布和修改产品bug;test: 测试分支，用于发布测试服务器共内部测试;dev: 开发分支，用于开发时测试和发布，随时合并新功能代码或bug修复; 3. 开发流程1 每个新功能基于dev分支，创建新分支开始，例如现在要增加一个登录功能：1234567// 当前位于dev分支git checkout -b feature-login// more codinggit add -Agit commit -m 'feature-login completed' 2 新功能完成，自己测试之后，需要合并到dev分支：12345678910// 当前位于dev分支git pull // 首先拉取远程分支// dev分支（冲突解决完成）clean之后git checkout feature-logingit rebase dev // 保留dev的其他人的提交记录并合并dev分支到当前新功能分支// dev 分支合并之后（可能有冲突需要解决）git checkout devgit rebase feature-login 这时的分支状态：3 接下来，可以删除feature-login分支：12// 当前位于dev分支git branch -d feature-login 4 这时，feature-login 基本开发完成，可以合并到test分支，发布给QA测试12// 当前位于 test 分支git rebase dev 5 如果QA测出bug需要修改，或者临时有需求变动，需要重复上述步骤，不过命名可以修改，例如 fix-login-bug-1024。如果是细节调整或者是晓得修改则可以在dev分支直接执行。6 所有功能测试无误之后，可以合并到 master 分支，发布生产环境12345// 当前位于 master 分支git rebase dev // 也可能根据不同功能的测试状态，会执行不同的合并操作git merge ... 4. 线上bug临时修改如果生产环境突然出现bug需要修改，或者要改一些细节部分，则需要直接在 master 上执行，然后合并到 dev。1234567891011121314151617181920// 当前位于 master 分支git checkout -b hotfix-bug1117// more codinggit add -Agit commit -m 'fixed hotfix-bug1117'git checkout mastergit rebase hotfix-bug1117// 然后发布// 最后，需要把修改合并到dev分支，假如刚才的提交commit是abcdefggit checkout devgit cherry-pick abcdefg// 可能需要解决冲突// 最后 删除 `hotfix-bug1117` 分支git branch -d hotfix-bug1117","categories":[{"name":"Technology","slug":"Technology","permalink":"http://mrzzcn.github.io/categories/Technology/"},{"name":"Git","slug":"Technology/Git","permalink":"http://mrzzcn.github.io/categories/Technology/Git/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://mrzzcn.github.io/tags/随笔/"},{"name":"Git","slug":"Git","permalink":"http://mrzzcn.github.io/tags/Git/"}]},{"title":"JavaScript The Good Parts","slug":"JavaScript-The-Good-Parts","date":"2015-05-24","updated":"2019-04-27","comments":true,"path":"2015/05/24/JavaScript-The-Good-Parts/","link":"","permalink":"http://mrzzcn.github.io/2015/05/24/JavaScript-The-Good-Parts/","excerpt":"使用一个method 方法定义新方法123456Function.prototype.method = function (name, func) &#123; if (!this.prototype[name]) &#123; this.prototype[name] = func; &#125; return this;&#125; 根据数字的正负来判断是使用Math.ceiling 还是Math.floor123Number.method(\"integer\", function () &#123; return Math[this &lt; 0 ? 'ceil' : 'floor'](this);&#125;);","text":"使用一个method 方法定义新方法123456Function.prototype.method = function (name, func) &#123; if (!this.prototype[name]) &#123; this.prototype[name] = func; &#125; return this;&#125; 根据数字的正负来判断是使用Math.ceiling 还是Math.floor123Number.method(\"integer\", function () &#123; return Math[this &lt; 0 ? 'ceil' : 'floor'](this);&#125;); 移除字符串首尾的空白123String.method(\"trim\", function () &#123; return this.replace(/^\\s+|\\s+$/g, '');&#125;) 闭包演示123456789101112var myObject = (function () &#123; var value = 0; return &#123; increment: function (inc) &#123; value += typeof inc === \"number\" ? inc : 1; &#125;, getValue: function () &#123; return value; &#125; &#125;;&#125;()); 缓存中间计算结果 - 斐波纳挈数组12345678910111213141516171819202122232425262728// 定义var memoizer = function (memo, formula) &#123; var recur = function (n) &#123; var result = memo[n]; if (typeof result !== 'number') &#123; result = formula(recur, n); memo[n] = result; &#125; return result; &#125;; return recur;&#125;;// 使用var fibonacci = memoizer([0, 1], function (recur, n) &#123; return recur(n-1) + recur(n - 2);&#125;);for (var i = 0; i &lt;= 10; i++) &#123; console.log(\"%d : %d\", i, fibonacci(i));&#125;// 扩展用法 阶乘var factorial = memoizer([1, 1], function (recur, n) &#123; return n * recur (n - 1)&#125;);for (var i = 1; i &lt;= 10; i++) &#123; console.log(\"%d : %d\", i, factorial(i));&#125; 如何实现继承 - 函数化 创建一个对象 有选择地定义私有实例变量和方法。这些就是函数中通过var语句定义的普通变量 给这个新对象扩充方法。这些方法拥有特权去访问参数，以及上一步中定义的变量。 返回这个新对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 这里是一个函数化构造器的伪代码模板（加粗的文本表示强调）：var **constructor** = function (spec, my) &#123; // 代码快内部不知道怎么加粗，哪位大神指点一下 var that, **其他私有变量**; my = my || &#123;&#125;; // **把共享的变量和函数添加到my中** that = &#123; name: \"**一个新对象**\" &#125;; // **给that添加特权方法** return that;&#125;// spec 对象包含构造器需要构造一个新实例的所哟信息。spec 的内容可能会被复制到私有变量中，或者被其他函数改变，或者方法可以在需要的时候访问spec的信息。（一个简化的方式是替换spec为一个单一的值。当构造对象过程中并不需要整个spec对象的时候，这是有用的。）// my 对象是一个为继承链中的构造器提供秘密共享的容器。my对象可以选择性地使用。如果没有传入一个my对象，那么会创建一个my对象// demovar mammal = function (spec) &#123; var that = &#123;&#125;; that.get_name = function () &#123; return spec.name; &#125;; that.says = function () &#123; return spec.saying || \"\"; &#125; return that;&#125;;var cat = function (spec) &#123; spec.saying = spec.saying || 'meow'; var that = mammal(spec); that.purr = function (n) &#123; var i, s = ''; for (i = 0; i &lt; n; i += 1) &#123; if (s) &#123; s += \"-\"; &#125; s += \"r\"; &#125; return s; &#125;; that.get_name = function () &#123; return that.says() + \" \" + spec.name + \" \" + that.says(); &#125;; return that;&#125;;var myCat = cat(&#123;name: \"Henrietta\"&#125;); 函数化模式还提供了一个处理父类方法的方法。我们会构造一个superior方法，它取得一个方法名并返回调用那个方法的函数。该函数会调用原来的方法，尽管属性已经变化了。1234567Object.method('superior', function (name) &#123; var that = this, method = that[name]; return function () &#123; return method.apply(that, arguments); &#125;;&#125;); 让我们在coolcat上试验一下，coolcat就像cat一样，除了它有一个更酷的调用父类方法的get_name方法。它只需要一点点的准备工作。我们会声明一个super_get_name变量，并且把调用superior方法所返回的结果赋值给它。123456789101112var coolcat = function (spec) &#123; var that = cat(spec), super_get_name = that.superior('get_name'); that.get_name = function (n) &#123; return 'like ' + super_get_name() + ' baby'; &#125;; return that;&#125;;var myCoolCat = coolcat(&#123;name: 'Bix'&#125;);var name = myCoolCat.get_name();console.log(name); // \"like meow Bix meow baby\" 部件我们可以从一套部件中把对象组装出来。例如，我们可以构造一个给任何对象添加简单事件处理特性的函数。他会给对象添加一个on方法、一个fire方法和一个私有的事件注册表对象：123456789101112131415161718192021222324252627282930313233343536373839404142434445var eventuality = function (that) &#123; var registry = &#123;&#125;; that.fire = function (event) &#123; // 在一个对象上触发一个事件。该事件可以是一个包含事件名称的字符串 // 或者是一个拥有包含事件名称的 type 属性的对象。 // 通过'on'方法注册的事件处理程序中匹配事件名称的函数将被调用。 var array, func, handler, i, type = typeof event === 'string' ? event : event.type; if (registry.hasOwnProperty(type)) &#123; array = registry[type]; for (i = 0; i &lt; array.length; i += 1) &#123; handler = array[i]; // 每个处理程序包含一个方法和一组可选的参数。 // 如果该方法是一个字符串形式的名字，那么寻找到该函数。 func = handler.method; if (typeof func === 'string') &#123; func = this[func]; &#125; // 调用一个处理程序。如果该条目包含参数，那么传递它们过去。否则，传递该事件对象。 func.apply(this, handler.parameters || [event]); &#125; &#125; return this; &#125;; that.on = function (type, method, parameters) &#123; // 注册一个事件。构造一条处理程序条目。将它插入到处理程序数组中， // 如果这种类型的事件还不存在，就构造一个。 var handler = &#123; method: method, parameters: parameters &#125;; if (registry.hasOwnProperty(type)) &#123; registry[type].push(handler); &#125; else &#123; registry[type] = [handler]; &#125; return this; &#125;; return that;&#125;; 我们可以在任何单独的对象上调用eventuality, 授予它事件处理方法。我们也可以赶在that被返回之前在一个构造器函数中调用它 eventuality(that);1234567891011121314151617181920212223eventuality(myCoolCat);myCoolCat.health = 100;myCoolCat.on('dead', function (event) &#123; var date = event.date; var killer = event.killer; console.log(\"%s killed me at %s\", killer, date);&#125;);myCoolCat.on('hurt', function () &#123; this.health -= 50; if (this.health &lt;= 0) &#123; var event = &#123; type: 'dead', killer: 'stone from sky', date: new Date() &#125;; this.fire(event); &#125; else &#123; console.log('nothing, who is the strong guy.'); &#125;&#125;);myCoolCat.fire(\"hurt\"); //nothing, who is the strong guy.myCoolCat.fire(\"hurt\"); //stone from sky killed me at Sat Mar 14 2015 15:47:29 GMT+0800 (CST) 数组与对象javascript 编程中，一个常见的错误是在必须使用数组时使用了对象，或者在必须使用对象时使用了数组。其实规则很简单：当属性名是小而连续的整数时，你应该使用数组。否则，使用对象。javascript 本身没有一个好的机制来区分数组和对象。我们可以通过定义自己的is_array函数来弥补这个缺陷：12345678910var is_array = function (value) &#123; return value &amp;&amp; typeof value === 'object' &amp;&amp; value.constructor === Array;&#125;;// 不过该方法在识别从不同的窗口(window)或者frame里构造的数组时会失败。下面是一个更好的方式// 上面这句话这里本人尚未理解，请高手指点var is_array = function (value) &#123; return Object.prototype.toString.apply(value) === '[object Array]';&#125;; 为数组扩充reduce函数1234567891011121314151617181920212223242526Array.method('reduce', function (f, value) &#123; var i; for (i = 0; i &lt; this.length; i += 1) &#123; value = f(this[i], value); &#125; return value;&#125;);// DEMOvar data = [4, 8, 15, 16, 23, 42];var add = function (a, b) &#123; return a + b;&#125;;var mult = function (a, b) &#123; return a * b;&#125;;var sum = data.reduce(add, 0);console.log(sum);// 108var product = data.reduce(mult, 1);console.log(product); // 7418880// 因为数组其实就是对象，所以我们可以直接给一个单独的数组添加方法data.total = function () &#123; return this.reduce(add, 0);&#125;;var total = data.total();console.log(total); // 108 为数组指定初始值123456789Array.dim = function (dimension, initial) &#123; var a = [], i; for (i = 0; i &lt; dimension; i += 1) &#123; a[i] = initial; &#125; return a;&#125;;var myArray = Array.dim(10, 0); //[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]// 注意这里不能使用我们之前说的method方法，应为那个方法是给某个类型的每一个具体的对象增加方法的，而这里我们是给Array这个 类型 增加方法，类似于某些静态语言中的静态方法或者类方法 数组排序sort 方法会array中的内容进行排序。但是它不能正确第给一组数字排序：12var myNumbers = [4, 8, 15, 16, 23, 42];myNumbers.sort(); // [15, 16, 23, 4, 42, 8] javascript 的默认比较函数把要被排序的元素都视为字符串。它尚未足够智能到在比较这些元素之前先检测他们的类型，所以当它比较这些数字的时候，会把它们转化为字符串，于是得到一个错的离谱的结果。辛运的是，你可以使用自己的比较函数来替换默认的比较函数。 你的比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第2个参数应该排在前面，则返回一个正数。 123myNumbers.sort(function (a, b) &#123; return a - b;&#125;); // [4, 8, 15, 16, 23, 42] 上面这个函数可以使数字正确排序，但它不能使字符串排序。如果我们想要给任何包含简单值的数组排序，必须要做更多的工作：12345678910var myStrings = ['aa', 'bb', 'a', 4, 8, 15, 16, 23, 42];myStrings.sort(function (a, b) &#123; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1;&#125;); //[4, 8, 15, 16, 23, 42, \"a\", \"aa\", \"bb\"] 对象数组排序12345678910111213141516171819202122232425262728293031323334353637383940414243// by 函数接受一个成员名字字符串做为参数，// 并返回一个可以用来对包含该成员的对象数组的进行排序的比较函数var by = function (name) &#123; return function (o, p) &#123; var a, b; if (typeof o === 'object' &amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) &#123; a = o[name]; b = p[name]; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125; else &#123; throw &#123; name: 'Error', message: 'Expected an object when sorting by ' + name &#125;; &#125; &#125;;&#125;var myPeople = [ &#123;first: 'Joe', last: 'Beasser'&#125;, &#123;first: 'Moe', last: 'Howard'&#125;, &#123;first: 'Joe', last: 'DeRita'&#125;, &#123;first: 'Shemp', last: 'Howard'&#125;, &#123;first: 'Larry', last: 'Fine'&#125;, &#123;first: 'Curly', last: 'Howard'&#125;];myPeople.sort(by('first'));/*[&#123;first: \"Curly\", last: \"Howard\"&#125;,&#123;first: \"Joe\", last: \"Beasser\"&#125;,&#123;first: \"Joe\", last: \"DeRita\"&#125;,&#123;first: \"Larry\", last: \"Fine\"&#125;,&#123;first: \"Moe\", last: \"Howard\"&#125;,&#123;tfirst: \"Shemp\", last: \"Howard\"&#125;]*/ sort 方法是不稳定的 排序的稳定性是指排序后数组中的相等值的相对位置没有发生改变，而不稳定性排序则会改变相等值的相对位置。详细内容参见排序算法。JavaScript的sort方法的稳定性根据不同浏览器的实现而不一致。可参见Array.prototype.sort中的介绍。 下面的调用：12345678910myPeople.sort(by('last')).sort(by('first'));/*[&#123;\"first\": \"Curly\", \"last\": \"Howard\"&#125;,&#123;\"first\": \"Joe\", \"last\": \"Beasser\"&#125;,&#123;\"first\": \"Joe\", \"last\": \"DeRita\"&#125;,&#123;\"first\": \"Larry\", \"last\": \"Fine\"&#125;,&#123;\"first\": \"Moe\", \"last\": \"Howard\"&#125;,&#123;\"first\": \"Shemp\", \"last\": \"Howard\"&#125;]*/ 不能保证产生正确的序列。如果你想基于多个键值进行排序，你需要再次做更多的工作。我们可以修改by函数，让其可以接受第2个参数，当主要的键值产生一个匹配的时候，另一个compare方法将被调用以决出高下。 123456789101112131415161718192021222324252627282930313233// by 函数接受一个成员名字字符串和一个可选的次要比较函数做为参数，// 并返回一个可以用来对包含该成员的对象数组进行排序的比较函数。// 当 o[name] 和 p[name] 相等时，次要比较函数被用来决出高下。var by = function (name, minor) &#123; return function (o, p) &#123; var a, b; if (o &amp;&amp; p &amp;&amp; typeof o === 'object' &amp;&amp; typeof p === 'object') &#123; a = o[name]; b = p[name]; if (a === b) &#123; return typeof minor === 'function' ? minor(o, p) : 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125; else &#123; throw &#123; name: 'Error', message: 'Expected an object when sorting by ' + name &#125;; &#125; &#125;;&#125;myPeople.sort(by('last', by('first')));[&#123;\"first\": \"Joe\", \"last\": \"Beasser\"&#125;,&#123;\"first\": \"Joe\", \"last\": \"DeRita\"&#125;,&#123;\"first\": \"Larry\", \"last\": \"Fine\"&#125;,&#123;\"first\": \"Curly\", \"last\": \"Howard\"&#125;,&#123;\"first\": \"Moe\", \"last\": \"Howard\"&#125;,&#123;\"first\": \"Shemp\", \"last\": \"Howard\"&#125;] 正则表达式 - 解析URL12345678910111213141516171819var parse_url = /^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;var url = \"http://www.ora.com:80/goodparts?q#fragment\";var result = parse_url.exec(url);var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];var blanks = ' ';var i;for (i = 0; i &lt; names.length; i += 1) &#123; console.log(\"%s:%s%s\", names[i], blanks.substring(names[i].length), result[i]);&#125;/* url: http://www.ora.com:80/goodparts?q#fragment scheme:http slash: // host: www.ora.com port: 80 path: goodparts query: q hash: fragment*/ 正则表达式 - 验证数字12345678910111213141516171819var parse_number = /^-?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d+)?$/i;var isNumber = function (value) &#123; var result = parse_number.test(value); console.log(\"%s %s a number\", value, result ? \"is\" : \"is not\");&#125;isNumber('1')// 1 is a numberisNumber('number')// number is not a numberisNumber('98.6')// 98.6 is a numberisNumber('132.21.86.100')// 132.21.86.100 is not a numberisNumber('123.45E-67')// 123.45E-67 is a numberisNumber('123.45D-67')//123.45D-67 is not a number// 数字可能由一个整数部分加上一个可选的负号、一个可选的小数部分和一个可选的指数部分构成 正则表达式中32个ASCII特殊字符集合：1234567891011121314/*!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;\\&#125;~*/var ascii32 = /(?:!|\"|#|\\$|%|&amp;|'|\\(|\\)|\\*|\\+|,|-|\\/|:|;|&lt;|=|&gt;|\\?|@|\\[|\\\\|]|\\^|_|`|\\&#123;|\\||\\&#125;|~)/;// 这是其中一种简写方式，不过依旧难以阅读var ascii32_short1 = /[!-\\/:-@\\[-`&#123;-~]/;// 正则表达式的一个方便之处就是类的求反。如果 [ 后的第一个字符是 ^ ,那么这个类会排除这些特殊字符。var not_ascii = /[^!-\\/:-@\\[-`&#123;-~]/; 糟粕javascript 有两组相等运算符：=== 和 !==, 以及它们邪恶的孪生兄弟 == 和 !=。=== 和 !== 这一组运算符会按照你期望的方式工作。如果来两个运算数类型一致并且拥有相同的值，那么 === 返回 true，!== 返回 false。而它们邪恶的孪生兄弟只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型，它们试图去强制转换值的类型。转换的规则复杂且难以记忆。这里有一些有趣的例子： 123456789101112'' == '0' // false0 == '' // true0 == '0' // truefalse == 'false' // falsefalse == '0' // truefalse == undefined // falsefalse == null // falsenull == undefined // true' \\t\\r\\n' == 0 // true == 运算符对传递性的缺乏值得我们警惕。我的建议是永远不要使用那对邪恶的孪生兄弟。相反，请始终使用 === 和 !==。如果以上所有比较使用 === 运算符，结果都是false。 传递性是一种编程约定。可以这么理解：对于任意的引用值x、y和z，如果 x == y 和 y == z 为true，那么x == z为true。而javascript中的 == 运算符在某些特例上违背了传递性。 最后 以一个自定义的JSON解析器 结尾吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246// 这是一个用JavaScript编写JSON解析器的实现方案：var json_parse = function () &#123; // 这是一个能把JSON文本解析成JavaScript数据结构的函数。 // 它是一个简单的递归降序解析器。 // 我们在另一个函数中定义此函数，以避免创建全局变量。 var at, // 当前字符索引 ch, // 当前字符 escapee = &#123; '\"' : '\"', '\\\\' : '\\\\', '/' : '/', b : 'b', f : '\\f', n : '\\n', r : '\\r', t : '\\t' &#125;, text, error = function (m) &#123; // 当某处出错时，调用error。 throw &#123; name : 'SyntaxError', messsage: m, at : at, text : text &#125;; &#125;, next = function (c) &#123; // 如果提供了参数 c, 那么检查它是否匹配当前字符。 if (c &amp;&amp; c !== ch) &#123; error(\"Expected '\" + c + \"' insttead of '\" + ch + \"'\"); &#125; // 获取下一个字符。当没有下一个字符时，返回一个空字符串。 ch = text.charAt(at); at += 1; return ch; &#125;, number = function () &#123; // 解析一个数字值。 var number, string = ''; if (ch === '-') &#123; string = '-'; next('-'); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; string += ch; next(); &#125; if (ch === '.') &#123; string += \".\"; while (next() &amp;&amp; ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; string += ch; &#125; &#125; if (ch == 'e' || ch == 'E') &#123; string += ch; next(); if (ch === '-' || ch === '+') &#123; string += ch; next(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; string += ch; next(); &#125; &#125; number = +string; if (isNaN(number)) &#123; error(\"Bad number\"); &#125; else &#123; return number; &#125; &#125;, string = function () &#123; // 解析一个字符串值。 var hex, i, string = '', uffff; // 当解析字符串值时，我们必须找到 \" 和 \\ 字符。 if (ch === '\"') &#123; while (next()) &#123; if (ch === '\"') &#123; next(); return string; &#125; else if (ch === '\\\\') &#123; next(); if (ch === 'u') &#123; uffff = 0; for (i = 0; i &lt; 4; i += 1) &#123; hex = parseInt(next(), 16); if (!isFinite(hex)) &#123; break; &#125; uffff = uffff * 16 + hex; &#125; string += String.fromCharCode(uffff); &#125; else if (typeof escapee[ch] === 'string') &#123; string += escapee[ch]; &#125; else &#123; break; &#125; &#125; else &#123; string += ch; &#125; &#125; &#125; error(\"Bad string\"); &#125;, white = function () &#123; // 跳过空白 while (ch &amp;&amp; ch &lt;= ' ') &#123; next(); &#125; &#125;, word = function () &#123; // true, false 或者 null switch (ch) &#123; case 't': next('t'); next('r'); next('u'); next('e'); return true; case 'f': next('f'); next('a'); next('l'); next('s'); next('e'); return false; case 'n': next('n'); next('u'); next('l'); next('l'); return null; &#125; error(\"Unexpected '\" + ch + \"'\"); &#125;, value, // 值函数的占位符。 array = function () &#123; // 解析一个数组值。 var array = []; if (ch === '[') &#123; white(); if (ch === ']') &#123; next(']'); return array; // 空数组 &#125; while (ch) &#123; array.push(value()); white(); if (ch === \"]\") &#123; next(']'); return array; &#125; next(','); white(); &#125; &#125; error(\"Bad array\"); &#125;, object = function () &#123; // 解析一个对象值 var key, object = &#123;&#125;; if(ch === '&#123;') &#123; next('&#123;'); white(); if (ch === \"&#125;\") &#123; next('&#125;'); return object; // 空对象 &#125; while (ch) &#123; key = string(); white(); next(\":\"); object[key] = value(); white(); if(ch === '&#125;') &#123; next('&#125;'); return object; &#125; next(\",\"); white(); &#125; &#125; error(\"Bad object\"); &#125;; value = function () &#123; // 解析一个JSON值。它可以是对象、数组、字符串、数字或一个词。 white(); switch (ch) &#123; case '&#123;': return object(); case '[': return array(); case '\"': return string(); case \"-\": return number(); default: return ch &gt;= '0' &amp;&amp; ch &lt;= '9' ? number() : word() ; &#125; &#125;; // 返回json_parse 函数。它能访问上述所有的函数和变量。 return function(source, reviver) &#123; var result; text = source; at = 0; ch = ' '; result = value(); white(); if (ch) &#123; error(\"Syntax error\"); &#125; // 如果存在reviver 函数，我们就递归地对这个新结构调用walk函数， // 开始时先创建一个临时的启动对象，并以一个空字符串作为键名保存结果， // 然后传递每个键值对给reviver函数去处理可能存在的转换。 // 如果没有reviver函数，我们就简单地返回这个结果。 return typeof reviver === 'function' ? function walk(holder, key) &#123; var k, v, value = holder[key]; if (value &amp;&amp; typeof value === 'object') &#123; for (k in value) &#123; if (Object.hasOwnProperty.call(value, k)) &#123; v = walk(value, k); if (v !== undefined) &#123; value[k] = v; &#125; else &#123; delete value[k]; &#125; &#125; &#125; &#125; return reviver.call(holder, key, value); &#125;(&#123;'': result&#125;, '') : result; &#125;&#125;(); This is the end.正文部分到此结束。第一次写读书笔记，一是加深自己的印象，二来方便以后查阅，毕竟纸张没有搜索功能。如果你也喜欢这篇文章欢迎转载，但本文代码版权属于《JavaScript 语言精粹》，小部分代码扩充是为了演示代码效果。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://mrzzcn.github.io/categories/Notes/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzzcn.github.io/tags/Javascript/"},{"name":"Douglas-Crockford","slug":"Douglas-Crockford","permalink":"http://mrzzcn.github.io/tags/Douglas-Crockford/"},{"name":"最佳实践","slug":"最佳实践","permalink":"http://mrzzcn.github.io/tags/最佳实践/"}]}]}